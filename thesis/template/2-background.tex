\chapter{Background}\label{chap:background}



This section introduces the EasyCrypt verification framework and provides essential background on the algebraic group model that forms our analysis.

\section{The EasyCrypt Verification Framework}
\label{sec:easycrypt-framework}

EasyCrypt~\cite{easycrypt} serves as our basic framework for mechanizing cryptographic security arguments. This tool specializes in formalizing and verifying security proofs for cryptographic constructions through rigorous mathematical reasoning. The coreof EasyCrypt is its Probabilistic Relational Hoare Logic (pRHL), which we utilize extensively throughout our bilateral equivalence proof to build exact correspondences between security games while maintaining control over probabilistic reasoning~\cite{Bar2012}.

Probabilistic Relational Hoare Logic (pRHL) enables us to establish that corresponding executions across different game contexts maintain identical success probabilities without requiring detailed characterization of intermediate distributions. Such relational reasoning proves particularly powerful for our tight reduction, where the primary objective is demonstrating perfect correspondence between adversarial advantages rather than computing absolute probability values~\cite{kyber2024}.

While EasyCrypt's standard reasoning strategies handle the majority of our proof obligations, certain technical steps in our bilateral reduction demand more sophisticated approaches that require global program analysis and explicit management of algebraic relationships. These include randomness-preserving transformations and complex oracle simulations that must maintain consistency across multiple game contexts. EasyCrypt addresses these requirements through specialized reasoning techniques and transformation rules, though their direct application requires careful orchestration in our specific proof context.

To address this complexity, the EasyCrypt ecosystem has evolved to include a comprehensive collection of generic libraries that encapsulate common cryptographic proof patterns into reusable components. These libraries abstract intricate reasoning steps into high-level "game transformation" lemmas and equivalence theorems that can be instantiated and composed within larger security arguments.


The formal verification process encompasses over 2000 lines of verified EasyCrypt code, representing one of the most substantial mechanizations of AGM-style reasoning to date. This level of formalization provides unprecedented confidence in the correctness of our security argument while establishing reusable infrastructure for future research in mechanized cryptographic verification.


\subsection{Core Concepts}

EasyCrypt operates on several key principles that make it particularly suitable for cryptographic analysis:

\paragraph{Probabilistic Relational Hoare Logic (pRHL).} EasyCrypt's cornerstone is probabilistic Relational Hoare Logic (pRHL), which enables reasoning about relationships between probabilistic programs~\cite{Bar2012}. In our context, pRHL allows us to establish probability equalities between different cryptographic games, such as our main lemma:
\[
\Pr[\text{IND\_CCA1\_P}(\text{ElGamal}, B).\text{main}() : \text{res}] = \Pr[\text{QDDH}(A_{\text{from\_INDCCA1}}(B)).\text{main}() : \text{res}]
\]

\paragraph{Game Transformations.} EasyCrypt provides several powerful tactics for transforming games while preserving their probability distributions:

\begin{itemize}
\item \textbf{byequiv transformations}: These are built upon pRHL and allow us to prove that two games have identical probability distributions by establishing a relational invariant between their executions.

\item \textbf{bypr transformations}: These enable reasoning about probability bounds and are particularly useful for establishing security reductions.

\item \textbf{rnd transformations}: These are pRHL-based tactics for reasoning about randomness. For example, in our proof we use:
\begin{lstlisting}[style=easycrypt, basicstyle=\footnotesize\ttfamily]
rnd (fun k' => loge k' - sk0{1} * y{1}) 
    (fun z => g ^ (z + sk0{1} * y{1})).
\end{lstlisting}
This transformation converts randomness from group elements to the exponent field, making the two games probabilistically equivalent.
\end{itemize}

\paragraph{Oracle Simulation.} EasyCrypt excels at reasoning about oracle-based security games. In our work, pRHL is crucial for:
\begin{itemize}
\item \textbf{Correctness}: Ensuring that simulated oracles produce the same outputs as real oracles for valid queries
\item \textbf{State Management}: Tracking the evolution of oracle state across game executions  
\item \textbf{Query Validation}: Verifying that adversarial queries satisfy the required algebraic constraints
\end{itemize}



\section{Background: Algebraic Group Model}
\label{sec:agm-background}

The Algebraic Group Model (AGM), introduced by Fuchsbauer, Kiltz, and Loss~\cite{fuchsbauer2018}, provides a framework for analyzing cryptographic schemes by restricting adversaries to be "algebraic."

In particular, instead of assuming an all-powerful attacker, the AGM will restricts adversaries to be algebraic, meaning that whenever they generate a new group element, they must also explain how it was algebraically derived from elements they have already seen~\cite{cong2022}. This model indicates the intuition that real cryptographic algorithms operate through concrete algebraic operations, rather than arbitrary black-box calculations.
By constrain adversaries in certain way, the AGM provides a intermediate position between the idealized models, such as the Random Oracle Model, and the entirely general Standard Model, allowing proofs to achieve a balance between realistic and easy to formalize.

\begin{definition}[Algebraic Adversary]
\label{def:algebraic-adversary}
An adversary $\mathcal{A}$ is algebraic if, whenever it outputs a group element $h \in \mathcal{G}$, it also provides a representation vector $\mathbf{z} = (z_1, \ldots, z_k) \in \mathbb{Z}_p^k$ such that:
\[
h = \prod_{i=1}^k g_i^{z_i}
\]
where $g_1, \ldots, g_k$ are all group elements that $\mathcal{A}$ has seen so far.
\end{definition}

The AGM assumption enables tighter security reductions by providing the reduction algorithm with algebraic representations of adversarial outputs, effectively giving the reduction "extraction" capabilities without explicit knowledge extraction.

\begin{assumption}[AGM Assumption]
\label{ass:agm}
All adversaries are algebraic in the sense of Definition~\ref{def:algebraic-adversary}.
\end{assumption}

This assumption is particularly well-suited for analyzing discrete logarithm-based schemes like ElGamal, as it captures the natural algebraic structure that such schemes possess while remaining weaker than the generic group model.


\section{Games framework}

The foundation of our proof lies in the characterization of two computation problems:

\subsection{IND-CCA1 Security Game for ElGamal.} 

The indistinguishability under chosen-ciphertext attacks (IND-CCA1) security game for ElGamal \KEM proceeds as follows: The challenger first introduce a key pair $\text{Gen}()\rightarrow(pk,sk)$ where $pk = g^x$ and $sk = x$ for a randomly chosen $x \leftarrow \mathbb{Z}_p$. Then, the adversary $A$ is given the public key $pk$ and then make decryption queries to a oracle $\text{Dec}(C, sk)$ that returns $K = C^x$ for valid ciphertexts $C \in \mathcal{G}$. At some point, the adversary requests a challenge by calling the encryption oracle only once. The challenger computes $ \text{Enc}(pk)\rightarrow(K_0^*, C^*)$ where $C^* = g^r$ and $K_0^* = (g^x)^r = g^{xr}$ for a  random $ \mathbb{Z}_p \rightarrow r$, then selects a random key $ \mathcal{K} \rightarrow K_1^*$, and finally return $(K_b^*, C^*)$ for a random bit $b$. Finally, The adversary will outputs a guess $b'$ and wins if $b' = b$.

The algorithm specification\cite{fuchsbauer2018} is detailed in Figure~\ref{fig:indcca1-algorithm}.

\begin{figure}[H]
\centering
\footnotesize
\begin{tabular}{|p{15cm}|}
\hline
\multicolumn{1}{|c|}{\textbf{IND-CCA1$_{\text{EG},\mathcal{G}}^A$ Security Game for ElGamal}} \\
\hline
\textbf{Algorithm:} \\
00 $x \leftarrow \mathbb{Z}_p$ \\
01 $X := g^x$ \\
02 $b' \leftarrow A^{\text{Dec},\text{Enc}}(X)$ \\
03 Return $b'$ \\
\hline
\textbf{Oracles Available to Adversary } $A$\textbf{:} \\
$\bullet$ \textbf{Dec}$(C)_a$ // Before Enc is called \\
\phantom{$\bullet$} 04 If $C \notin \mathcal{G}$ Return $\perp$ \\
\phantom{$\bullet$} 05 $K := C^x$ \\
\phantom{$\bullet$} 06 Return $K$ \\
\\
$\bullet$ \textbf{Enc}$()$ // One time only \\
\phantom{$\bullet$} 07 $r \leftarrow \mathbb{Z}_p$ \\
\phantom{$\bullet$} 08 $C^* := g^r$ \\
\phantom{$\bullet$} 09 $K^* := X^r$ \\
\phantom{$\bullet$} 10 $K_1^* \leftarrow \mathcal{K}$ // random key \\
\phantom{$\bullet$} 11 $b \leftarrow \{0,1\}$ \\
\phantom{$\bullet$} 12 Return $(K_b^*, C^*)$ \\
\hline
\textbf{ElGamal KEM Operations:} \\
$\bullet$ \textbf{Gen}$(\mathcal{G}) \rightarrow (pk, sk)$: $x \leftarrow \mathbb{Z}_p$; $X := g^x$; Return $(X, x)$ \\
$\bullet$ \textbf{Enc}$(pk) \rightarrow (K, C)$: $r \leftarrow \mathbb{Z}_p$; $C := g^r$; $K := pk^r$; Return $(K, C)$ \\
$\bullet$ \textbf{Dec}$(C, sk) \rightarrow K$: If $C \notin \mathcal{G}$ Return $\perp$; $K := C^{sk}$; Return $K$ \\
\hline
\textbf{Advantage Definition:} \\
$\mathsf{Adv}^{\text{IND-CCA1}}_{\text{ElGamal}}(A) = \left|\Pr[b' = b] - \frac{1}{2}\right|$ \\
where $b$ is the random bit used in the Enc oracle \\
\hline
\textbf{Security Goal:} \\
Adversary $A$ should not be able to distinguish between $K_0^* = g^{xr}$ (real key) and $K_1^*$ (random key) \\
even with access to decryption oracle before receiving the challenge $(K_b^*, C^*)$ \\
\hline
\end{tabular}
\caption{IND-CCA1 security game for ElGamal encryption. The adversary has access to a decryption oracle before the challenge phase, then must distinguish between a real session key and a random key.}
\label{fig:indcca1-algorithm}
\end{figure}






\subsection{q-DDH Problem.} The q-Decisional Diffie-Hellman (q-DDH) problem will ask one to distinguish between two distributions over group elements. 
By given a tuple $(g^x, g^{x^2}, \ldots, g^{x^q}, g^r, T)$ where $x, r \leftarrow \mathbb{Z}_p$ are random, the attacker must determine whether $T = g^{xr}$ (real distribution) or $T = g^{xr+z}$ for a random $z \leftarrow \mathbb{Z}_p$ (random distribution).

The specification\cite{fuchsbauer2018} is detailed below in Figure~\ref{fig:qddh-algorithm}.


\begin{figure}[H]
\centering
\footnotesize
\begin{tabular}{|p{15cm}|}
\hline
\multicolumn{1}{|c|}{\textbf{q-DDH$_{\mathcal{G},q}^A$ Problem}} \\
\hline
\textbf{Algorithm:} \\
00 $x, r, z \leftarrow \mathbb{Z}_p$ \\
01 $b \leftarrow \{0,1\}$ \\
02 $T_0 := g^{xr}$, $T_1 := g^{xr+z}$ \\
03 $b' \leftarrow A(g^x, g^{x^2}, \ldots, g^{x^q}, g^r, T_b)$ \\
04 Return $b'$ \\
\hline
\textbf{Challenge Structure Given to Distinguisher } $A$\textbf{:} \\
$\bullet$ \textbf{Powers of } $x$: $(g^x, g^{x^2}, g^{x^3}, \ldots, g^{x^q})$ \\
$\bullet$ \textbf{Random element:} $g^r$ where $r \leftarrow \mathbb{Z}_p$ \\
$\bullet$ \textbf{Target element:} $T \in \{g^{xr}, g^{xr+z}\}$ where $z \leftarrow \mathbb{Z}_p$ \\
\hline
\textbf{Distinguishing Goal:} \\
$\bullet$ \textbf{Real distribution } $\mathcal{D}_0$: $T = g^{xr}$ (DDH tuple) \\
$\bullet$ \textbf{Random distribution } $\mathcal{D}_1$: $T = g^{xr+z}$ (random element) \\
\\
Distinguisher $A$ must output a bit $b'$ indicating which distribution the challenge comes from \\
\hline
\textbf{Advantage Definition:} \\
$\mathsf{Adv}^{q\text{-DDH}}_{\mathcal{G}}(A) = \left|\Pr[A(\mathcal{D}_0) = 1] - \Pr[A(\mathcal{D}_1) = 1]\right|$ \\
where $\mathcal{D}_0 = (g^x, g^{x^2}, \ldots, g^{x^q}, g^r, g^{xr})$ \\
and $\mathcal{D}_1 = (g^x, g^{x^2}, \ldots, g^{x^q}, g^r, g^{xr+z})$ \\
\hline
\textbf{Hardness Assumption:} \\
For any probabilistic polynomial-time algorithm $A$: \\
$\mathsf{Adv}^{q\text{-DDH}}_{\mathcal{G}}(A) \leq \text{negl}(\lambda)$ \\
\\
The q-DDH assumption states that even given the first $q$ powers of $x$, \\
it remains computationally hard to distinguish $g^{xr}$ from $g^{xr+z}$ \\
\hline
\textbf{Relationship to Standard DDH:} \\
$\bullet$ Standard DDH: Given $(g^a, g^b, g^c)$, distinguish $c = ab$ from random $c$ \\
$\bullet$ q-DDH: Given $(g^x, \ldots, g^{x^q}, g^r, T)$, distinguish $T = g^{xr}$ from $T = g^{xr+z}$ \\
$\bullet$ q-DDH $\Rightarrow$ DDH but the converse may not hold \\
\hline
\end{tabular}
\caption{q-DDH (q-Decisional Diffie-Hellman) problem. The distinguisher receives the first $q$ powers of a secret exponent $x$ along with $g^r$ and must distinguish between $g^{xr}$ and $g^{xr+z}$ for random $z$.}
\label{fig:qddh-algorithm}
\end{figure}





